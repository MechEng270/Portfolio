#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    _lightLeft,      sensorReflection)
#pragma config(Sensor, in2,    _lightMid,       sensorReflection)
#pragma config(Sensor, in3,    _lightRight,     sensorReflection)
#pragma config(Sensor, dgtl1,  _btnStop,        sensorTouch)
#pragma config(Sensor, dgtl2,  _btnStart,       sensorTouch)
#pragma config(Sensor, dgtl3,  _sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl5,  _encRight,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  _encLeft,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  _LED_Right,      sensorDigitalOut)
#pragma config(Sensor, dgtl10, _LED_Left,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, _armLimit_low,   sensorTouch)
#pragma config(Sensor, dgtl12, _armLimit_high,  sensorTouch)
#pragma config(Sensor, I2C_1,  _armEncoder,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           _motorArm,      tmotorVex269_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port7,           _motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           _motorLeft,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// -----------  DO NOT MODIFY anything ABOVE this line! ----------- //

//Authors : Joseph Kaw
#include "ProjectBackgroundProcesses2022.c"

/* Timers:
T_1	Free
T_2	Free
T_3	Free
T_4	Used by checkButtons() -- DO NOT USE
*/

// ---------------------- Defining physical robot parameters --------------------------
// Update these numbers to match the physical robot (information found in the lab manual)
int drivingWheelDiameter = 103;		// diameter of the driving wheels [mm]
int robotWidth = 250;							// width of the robot including the wheel thickness [mm]
int wheelWidth = 22;							// width of the driving wheel [mm]
float drivingWheelRatio = 0.0;	// ratio of wheel shaft rotations to wheel encoder shaft rotations
float armRatio = 0.0;						// ratio of arm shaft rotations to arm encoder shaft rotations
float wheelEncoderCounts = 360;	// number of encoder ticks per 1 revolution of wheel encoder
float armEncoderCounts = 240.448;		// number of encoder ticks per 1 revolution of arm encoder
// ------------------------------------------------------------------------------------

//  ----------------------- Function Prototypes  ---------------------------
//Below listed are all our function prototypes that we used.
void waitForStart();
float armtodeg();
float wheeltomilli();
void moveArm(float deg,float kp);
void driveStraight(float distance,float kp, float ki);
void turn(float angle, float Kp, float Ki);
void sonicDrive(float distance,float kp, float ki, float kps);
void linefollow(int power);
// -------------------------------------------------------------------------

// *************************** Main Task ***************************************
task main() {
	//Background Tasks
	startTask(checkArm);       // DO NOT DELETE THIS LINE
	startTask(checkButtons);   // DO NOT DELETE THIS LINE
	startTask(filterSonar);		 // DO NOT DELETE THIS LINE
	// DO NOT PUT YOUR CODE BEFORE THIS LINE!!!
	//Waits for user to click the start button
	waitForStart();
	//Ensures arm is at the highest position when starting
	armUp(30);
	//Sets the current arm postion to zero
	setSensor(EncoderArm,0);
	//lowers it to the gap of the payload
	moveArm(-15,6);
	//drives arms length away from the payload
	sonicDrive(270,2.5,2.5,0.2);
	//raises arm with the payload on it
	armUp(30);
	//drives backwards for 250mm
	driveStraight(-250,2.5,2.5);
	//delays for 100ms
	delay(100);
	//turns counterclockwise 90 degrees
	turn(90,2.5,2.5);
	//delays by 100ms
	delay(100);
	//drives straight for 370mm
	driveStraight(370,2.5,2.5);
	//delays by 100ms
	delay(100);
	//turns clockwise 90 degrees
	turn(-90,2.5,2.5);
	//drives straight for 1300mm
	driveStraight(1300,2.5,2.5);
	//turns clockwise 90 degrees
	turn(-90,2.5,2.5);
	//drives straight for 200mm
	driveStraight(200,2.5,2.5);
	//lower arm to drop the payload off
	moveArm(-15,6);
	////drives backwards for 100mm
	driveStraight(-100,2.5,2.5);
	//turns counterclockwise 90 degrees
	turn(180,2.5,2.5);
	//drives straight for 350mm
	driveStraight(350, 2.5,2.5);
	//Follows the brown line
	linefollow(30);
	//Drive straight till the finish zone
	driveStraight(400,2.5,2.5);
	stopAllTasks();	// end of program - stop everything
}
// *****************************************************************************
//  ---------------------- Function Definitions -----------------------------

//The function waitForStart enables to user to make the robot
//start only when the button is pressed.
void waitForStart(){
	//The variable is initialised as an integer zero before start button is pressed
	int Initialise = 0;
	//The while function checks if button is pressed
	while(Initialise ==0){
		//checking to see if the start button is pressed, it will check if it is true
		//sets button value to 1
		Initialise = readSensor(StartButton);
		//rechecks sensor after 50 milliseconds
		delay(50);
		}
	//if start button is pressed the initialised value of 1 delays 0.5 secs and proceeds
	delay(500);
	}

//The function armtodeg takes the arm encoder count and then changes it to a degree of the current position
float armtodeg(){
	//(21)(240.448)counts for 360 deg of the arm rotated or 360/(21 x 240.448) degrees rotated per count
	//highest postion is at 47 deg
	float maxangle = 47;
	int count =  readSensor(EncoderArm) ;
	float deg =(float)( (360/(21*240.448)) *(float)count + maxangle);
	//retunrs the current position
	return (deg);
	}

//The function wheeltomilli takes the wheel encoder count and converts them to travelled distance in mm
float wheeltomilli(){
	//1800 counts for 3(103)(pi)mm travelled or (103/600)(pi) mm travelled per count
	//takes average of wheel distance
	float distance = 0.0;
	int count = readSensor(RightEnc);
	distance = (float) ((float)count *  (103*3.14)/(600) );
	//returns the distance travelled by wheel
	return distance;
	}

//The function moveArm rotates the arm to a specified angle in degrees using a p controller
void moveArm(float deg,float kp){
	//sets inital arm position as reference point
	setSensor(EncoderArm,0);
	//initialises values pos : postion, pwr : power, u : the output of p controller and error as integers
	int pos,pwr,u,error;
	//while the power level is fairly high continues to move motor
	do{
		//uses p controller to move arm
		pos = armtodeg();
		error = deg - pos;
		u = (int)kp * error;
		//ensures power is between -50 and 50
		pwr = saturate(u,-50,50);
		motorPower(ArmMotor, pwr);
	}while(abs(error) > 10);
	//turns motor power off to 0
	motorPower(ArmMotor,0);
}

//The function driveStraight drivesd a specified distance in mm and then stops
void driveStraight(float distance,float kp, float ki){
	//sets starting point as refernce point
	setSensor(LeftEnc,0);
	setSensor(RightEnc,0);
	//initialises values pwr : power, error2 : equalises power between the motors, u1 : the output of the p controller for the distance as integers
	int pwr,error2,u1;
	//initialises pos : power, u2 : he output of the p controller for the motors as integers, error1 : difference of target distance and position
	//e and kps as float type.
	float pos,u2, error1;
	float e = 0;
	float kps = 0.5;

	//while loop for when motor power is still fairly high
	do{
		//error for the distance(PI control) and call function wheeltomilli
		pos = wheeltomilli();
		error1 = distance - pos;
		u1 = (int)(kp * error1 + ki*e);
		//if power output is not saturated ,the pi controller intergrates
		if (abs(u1) < 50){
			e = e + error1;
			}
		//This allows the power to be saturated if outside these bounds
		pwr = saturate(u1,-50,50);
		//error for the wheel power inbalance(P control)
		error2 = readSensor(LeftEnc) - readSensor(RightEnc);
		u2 = (float)(kps*error2);
		//sets motor power
		motorPower(RightMotor,pwr + u2);
		motorPower(LeftMotor,pwr - u2);
		//While loop exits the loop if the error is below 10.
	}while(abs(error1) > 10);
	//turns motor off
	motorPower(RightMotor,0);
	motorPower(LeftMotor,0);
}

//The function turn rotates the robot to an angle inputed and then stops (Positive
//values results in a ounter-clockwise turn
void turn(float angle, float Kp, float Ki) {
	//sets initial placement as reference
	setSensor(RightEnc,0);
	//initialises variables, error : the difference between target degree and current degree, position : current position
	//e : integrated error as float variables
	float error,position,e;
	float u = 0;
	//initalised pwr: power of motor and angleValue : desirred arc length to be swept as integers
	int pwr;
	int angleValue;
	//converts the angle to arc length((pi)(diametre)(angle/360))
	angleValue = ((3.14)*(robotWidth+wheelWidth) * angle)/360;
	//do while loop until the error is within tolerance
	do{
			//finds postion and sets error as difference between distance travelled by wheel and the desired arc length
	    position =wheeltomilli();
	    error = angleValue - position;
	    u = Kp * error + Ki*e;

	    //checks to see if the absolute value is smaller than 50
	    if (abs(u) < 50){
				e = e + error;
				}
			//saturates the power if it exceeds these outer bounds
	    pwr = (int) saturate(u, -50, 50);
	    //turns counterclockwise for positive values and clockwise for negative values
			motorPower(RightMotor,pwr );
			motorPower(LeftMotor,-pwr );
			//exits the looop when error is within tolerance
	 }
	while(abs(error)> 8 );
	//turns motor off
	motorPower(RightMotor,0 );
	motorPower(LeftMotor,0 );
}


//The function linefollow allows the robot to continue moving along the brown line and stop when it sensors the colours black.
void linefollow(int power){
	//initialising variable i, error:  ensures robot is driving striaght, both as integers
	int i = 1, error;
	//values of sensor set to zero all initialised as variables
	int left = 0;
	int mid = 0;
	int right = 0;
	//initialise variable u: output of the p controller, kps : k value for the drivestraight, both as float type.
	float u;
	float kps = 0.2;
	//sets limits of brown and if on edges of brownline(between)
	//intiatialise variable BUp as an interger : upperlimit of brown
	int BUp = 2300;
	//initalise variable BLow as an integer : lower limit of brown
	int BLow = 1000;
	//initialise varaible BLLow as an integer : lower black limit value
	int BLLow = 2301;
	//saturates power and drives forward for 0.5 sec to get over the black line at the start
	int pwr;
	power = saturate(power,-100,100);
	pwr = (int)(power*127)/100;
	//Sets power to the motors
	motorPower(LeftMotor, pwr);
	motorPower(RightMotor, pwr);
	//delays by 500ms
	delay(500);
	//sets motor power to zero
	motorPower(LeftMotor, 0);
	motorPower(RightMotor,0);
	//while loop while black isn't detected
	while(i == 1){
	  left = readSensor(LeftLight);
		mid = readSensor(MidLight);
		right = readSensor(RightLight);
		//if detects black ,its at end of the line(assuming it starts on brown)
		if (left >= BLLow || mid >= BLLow|| right >= BLLow) {
			i = 0;
		}
		//if any of the sensors detect brown
		if (((right < BUp) && (right > BLow)) ||  ((mid < BUp) && (mid > BLow)) || ((left < BUp) && (left > BLow))){
			//if left sensor detects brown and is greater than right, then will turn right
			if ((left > right) && (left >= BLow)){
					while(1){
						//exits loop if black is detected or the middle sensor is on the brown line
						if (left >= BLLow || mid >= BLLow || right >= BLLow || (mid >= BLow && mid <= BUp)){
								break;
								}
						//gets current sensor values for left and middle sensor
						left = readSensor(LeftLight);
						mid = readSensor(MidLight);
						//turns the robot to the left
						motorPower(LeftMotor, -pwr);
						motorPower(RightMotor, pwr);
						}
				}
					//if right sensor detects brown and is greater than left, then will turn left
				else if ((left < right) && (right >= BLow)){
					while(1){
						//exits loop if black is detected or the middle sensor is on the brown line
						if (right >= BLLow || mid >= BLLow || left >= BLLow || (mid >= BLow && mid <= BUp)){
							break;
							}
							//gets current sensor values for right and middle sensor
						right = readSensor(RightLight);
						mid = readSensor(MidLight);
							//turns the robot to the right
						motorPower(LeftMotor, pwr);
						motorPower(RightMotor,-pwr);
						}
					}
						//else will drive straight
						else {
							while (1) {
								// if black is detected or the middle sensor isnt detecting brown
								if (mid < BLow || left > BLLow || mid > BLLow || right > BLLow) {
								break;
									}
								//gets current sensor values for middle sensor
								mid = readSensor(MidLight);
								//uses p controller to drive straight
								error = readSensor(LeftEnc) - readSensor(RightEnc);
								u = (float)(kps*error);
								motorPower(LeftMotor, pwr - u);
								motorPower(RightMotor, pwr + u);
								}
							}
		}
	}
		//Turns both motors off
		motorPower(LeftMotor, 0);
		motorPower(RightMotor, 0);
}


//The function sonicDrive drives straight using an ultasonic sesnor and a p contoller
//to a specified distance in mm away from obstacle.
void sonicDrive(float distance,float kp, float ki, float kps){
	//initialises pwr : power of motors at 50, error : equalises the motors, u: output of the p controller as
	//integers
	int pwr = 50;
	int error,u;
	//Sets value of range as distance away from obstavle
	float range = readSensor(sonarSensor);
	//while nothing is in its range, continues to drive forward
	while(range == -1){
		//error for the wheel power inbalance(P control)
		error = readSensor(LeftEnc) - readSensor(RightEnc);
		u = (int)(kps*error);
		//sets motor power
		motorPower(RightMotor,pwr + u);
		motorPower(LeftMotor,pwr - u);
		//updates if anthing in range
		range = readSensor(sonarSensor);
		}
	//when in sonar range uses drivestraight function
	driveStraight(range - distance,kp,ki);
}
